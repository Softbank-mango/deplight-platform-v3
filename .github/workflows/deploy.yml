name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production
      target_repository:
        description: 'Target repository to deploy (user repo URL)'
        required: false
        type: string
      target_branch:
        description: 'Target repository branch'
        required: false
        default: 'main'
        type: string
      deployment_id:
        description: 'Deployment ID from dashboard'
        required: false
        type: string

permissions:
  id-token: write
  contents: write  # For creating GitHub releases

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: 513348493870.dkr.ecr.ap-northeast-2.amazonaws.com
  ECR_REPOSITORY: delightful-deploy
  ECS_CLUSTER: delightful-deploy-cluster
  ECS_SERVICE: delightful-deploy-service

jobs:
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.target_repository != ''

    outputs:
      release-tag: ${{ steps.create-release.outputs.tag }}
      release-url: ${{ steps.create-release.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get latest release version
        id: get-version
        run: |
          # Get the latest release tag, or default to v0 if none exist
          LATEST_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "v0")

          # Extract numeric version (remove 'v' prefix)
          if [ "$LATEST_TAG" = "v0" ]; then
            NEXT_VERSION=1
          else
            CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/v//')
            NEXT_VERSION=$((CURRENT_VERSION + 1))
          fi

          NEW_TAG="v${NEXT_VERSION}"
          echo "new-tag=${NEW_TAG}" >> $GITHUB_OUTPUT
          echo "Next release version: ${NEW_TAG}"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create GitHub Release
        id: create-release
        run: |
          REPO_URL="${{ github.event.inputs.target_repository }}"
          REPO_NAME=$(echo $REPO_URL | sed 's|.*/||' | sed 's|\.git$||')
          TAG="${{ steps.get-version.outputs.new-tag }}"

          gh release create "$TAG" \
            --title "Deployment ${TAG} - ${REPO_NAME}" \
            --notes "Automated deployment for ${REPO_NAME} from commit ${{ github.sha }}" \
            --target "${{ github.ref_name }}"

          RELEASE_URL=$(gh release view "$TAG" --json url --jq '.url')

          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "url=${RELEASE_URL}" >> $GITHUB_OUTPUT
          echo "Created release: ${RELEASE_URL}"
        env:
          GH_TOKEN: ${{ github.token }}

  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: [create-release]
    if: always() && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')

    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      app-port: ${{ steps.ai-analysis.outputs.port || '8000' }}
      cpu: ${{ steps.ai-analysis.outputs.cpu || '256' }}
      memory: ${{ steps.ai-analysis.outputs.memory || '512' }}
      release-tag: ${{ needs.create-release.outputs.release-tag }}

    steps:
      - name: Parse repository URL
        id: parse-repo
        run: |
          TARGET_REPO="${{ github.event.inputs.target_repository }}"

          if [ -n "$TARGET_REPO" ]; then
            # Extract owner/repo from URL if it's a full GitHub URL
            # Supports formats: https://github.com/owner/repo, https://github.com/owner/repo.git
            REPO_PATH=$(echo "$TARGET_REPO" | sed -E 's|https?://github.com/||' | sed 's|\.git$||')
            echo "repository=${REPO_PATH}" >> $GITHUB_OUTPUT
            echo "Parsed repository: ${REPO_PATH}"
          else
            echo "repository=${{ github.repository }}" >> $GITHUB_OUTPUT
            echo "Using default repository: ${{ github.repository }}"
          fi

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.parse-repo.outputs.repository }}
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          path: ${{ github.event.inputs.target_repository && 'user_repo' || '.' }}

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Analyze user code with Lambda AI
        if: github.event.inputs.target_repository
        id: ai-analysis
        run: |
          echo "ðŸ” Analyzing user repository with AI..."

          # Get file list from user_repo
          cd user_repo
          FILES=$(find . -type f -not -path "./.git/*" | head -100 | jq -R -s -c 'split("\n")[:-1]')

          # Get README if exists and encode safely with jq
          if [ -f README.md ]; then
            README_CONTENT=$(cat README.md | head -100 | jq -Rs .)
          else
            README_CONTENT='""'
          fi

          # Create payload using jq for safe JSON encoding
          PAYLOAD=$(jq -n \
            --arg repo "${{ github.event.inputs.target_repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg branch "${{ github.event.inputs.target_branch }}" \
            --argjson files "$FILES" \
            --argjson readme "$README_CONTENT" \
            '{repository: $repo, commit_sha: $sha, branch: $branch, file_list: $files, readme_content: $readme}')

          # Generate analysis ID based on repo and commit
          ANALYSIS_ID=$(echo -n "${{ github.event.inputs.target_repository }}-${{ github.sha }}" | md5sum | cut -d' ' -f1 | cut -c1-24)
          echo "Analysis ID: $ANALYSIS_ID"

          # Call Lambda AI asynchronously (no wait for response)
          echo "ðŸ” Triggering async AI analysis..."
          aws lambda invoke \
            --function-name delightful-deploy-ai-analyzer \
            --invocation-type Event \
            --payload "$PAYLOAD" \
            --cli-binary-format raw-in-base64-out \
            --region ap-northeast-2 \
            /tmp/lambda_invoke_response.json

          echo "âœ… Lambda invoked asynchronously"

          # Poll S3 for buildspec file (indicates analysis complete)
          S3_BUCKET="delightful-deploy-artifacts-513348493870"
          S3_BUILDSPEC_KEY="analysis/${ANALYSIS_ID}/buildspec"
          MAX_WAIT=300  # 5 minutes
          WAIT_TIME=0
          POLL_INTERVAL=10

          echo "â³ Waiting for AI analysis to complete..."
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            if aws s3 ls "s3://${S3_BUCKET}/${S3_BUILDSPEC_KEY}" >/dev/null 2>&1; then
              echo "âœ… Analysis complete! Files generated in S3."
              break
            fi
            echo "  â³ Waiting... (${WAIT_TIME}s/${MAX_WAIT}s)"
            sleep $POLL_INTERVAL
            WAIT_TIME=$((WAIT_TIME + POLL_INTERVAL))
          done

          if [ $WAIT_TIME -ge $MAX_WAIT ]; then
            echo "âŒ Timeout waiting for AI analysis"
            exit 1
          fi

          # Download buildspec to extract configuration
          aws s3 cp "s3://${S3_BUCKET}/analysis/${ANALYSIS_ID}/buildspec" /tmp/buildspec.yml

          # Extract port from buildspec or use defaults
          APP_PORT=8000
          CPU=256
          MEMORY=512

          # Try to extract port from buildspec if it contains environment variables
          if grep -q "APP_PORT" /tmp/buildspec.yml 2>/dev/null; then
            APP_PORT=$(grep "APP_PORT" /tmp/buildspec.yml | head -1 | grep -oP '\d+' || echo "8000")
          fi

          echo "Using configuration: Port=${APP_PORT}, CPU=${CPU}, Memory=${MEMORY}"

          echo "port=${APP_PORT}" >> $GITHUB_OUTPUT
          echo "cpu=${CPU}" >> $GITHUB_OUTPUT
          echo "memory=${MEMORY}" >> $GITHUB_OUTPUT
          echo "analysis_id=${ANALYSIS_ID}" >> $GITHUB_OUTPUT

          echo "âœ… Analysis complete: Port=${APP_PORT}, CPU=${CPU}, Memory=${MEMORY}"

          cd ..

      - name: Download AI-generated Dockerfile from S3
        if: github.event.inputs.target_repository
        run: |
          echo "ðŸ“¥ Downloading AI-generated Dockerfile from S3..."
          ANALYSIS_ID="${{ steps.ai-analysis.outputs.analysis_id }}"
          S3_BUCKET="delightful-deploy-artifacts-513348493870"

          # Download Dockerfile from S3
          aws s3 cp "s3://${S3_BUCKET}/analysis/${ANALYSIS_ID}/dockerfile" ./user_repo/Dockerfile || echo "âš ï¸ No Dockerfile in S3, will use existing"

          echo "âœ… Dockerfile ready"
          ls -la ./user_repo/Dockerfile || echo "No Dockerfile found"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="deploy-${SHORT_SHA}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build Docker image
        run: |
          # If target_repository is provided, build from user_repo, otherwise use demo_app
          BUILD_PATH="${{ github.event.inputs.target_repository && 'user_repo' || './test/fastapi_demo' }}"
          docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.image-tag }} \
                       -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest \
                       $BUILD_PATH

      - name: Run security scan
        run: |
          echo "Running security scan..."
          # Add Trivy or other security scanning here

      - name: Push to ECR
        run: |
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.image-tag }}
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Update DynamoDB deployment record
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          DEPLOYMENT_ID="deploy-${{ steps.meta.outputs.short-sha }}"

          aws dynamodb put-item \
            --table-name delightful-deploy-deployment-history \
            --item "{
              \"id\": {\"S\": \"${DEPLOYMENT_ID}\"},
              \"timestamp\": {\"S\": \"${TIMESTAMP}\"},
              \"repository\": {\"S\": \"${{ github.repository }}\"},
              \"commit_sha\": {\"S\": \"${{ github.sha }}\"},
              \"branch\": {\"S\": \"${{ github.ref_name }}\"},
              \"pusher\": {\"S\": \"${{ github.actor }}\"},
              \"image_tag\": {\"S\": \"${{ steps.meta.outputs.image-tag }}\"},
              \"status\": {\"S\": \"building\"}
            }"

  deploy-infrastructure:
    name: Deploy Infrastructure (Terraform)
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: ./mango/infrastructure/terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./mango/infrastructure/terraform
        run: |
          terraform plan \
            -var="image_tag=${{ needs.build-and-test.outputs.image-tag }}" \
            -var="commit_sha=${{ github.sha }}" \
            -var="container_port=${{ needs.build-and-test.outputs.app-port }}" \
            -var="container_cpu=${{ needs.build-and-test.outputs.cpu }}" \
            -var="container_memory=${{ needs.build-and-test.outputs.memory }}" \
            -out=tfplan

      - name: Terraform Apply
        continue-on-error: true  # ì´ë¯¸ ì¡´ìž¬í•˜ëŠ” ë¦¬ì†ŒìŠ¤ëŠ” ë¬´ì‹œ
        working-directory: ./mango/infrastructure/terraform
        run: terraform apply -auto-approve tfplan

      - name: Get ECS Service info
        id: ecs
        run: |
          ECS_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0]')

          RUNNING_COUNT=$(echo $ECS_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $ECS_INFO | jq -r '.desiredCount')

          echo "running-count=${RUNNING_COUNT}" >> $GITHUB_OUTPUT
          echo "desired-count=${DESIRED_COUNT}" >> $GITHUB_OUTPUT

  deploy-ecs:
    name: Deploy to ECS (Rolling)
    needs: [build-and-test, deploy-infrastructure]
    if: always() && needs.build-and-test.result == 'success'  # Terraform ì‹¤íŒ¨í•´ë„ ê³„ì†
    runs-on: ubuntu-latest

    outputs:
      alb-dns: ${{ steps.alb.outputs.dns }}
      url: ${{ steps.alb.outputs.url }}

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current task definition
        id: task-def
        run: |
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "task-def-arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT

      - name: Describe task definition JSON
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ steps.task-def.outputs.task-def-arn }} \
            --query 'taskDefinition' > task-def.json

      - name: Register new task definition (updated image)
        id: register
        run: |
          IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-test.outputs.image-tag }}"
          cat task-def.json | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' > task-def-clean.json
          cat task-def-clean.json | jq --arg IMG "$IMAGE" '.containerDefinitions[0].image = $IMG' > task-def-updated.json

          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-def-updated.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "new-task-def-arn=${NEW_TASK_DEF_ARN}" >> $GITHUB_OUTPUT
          echo "Registered: ${NEW_TASK_DEF_ARN}"

      - name: Update ECS service (rolling)
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.register.outputs.new-task-def-arn }} \
            --force-new-deployment > /dev/null

          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          echo "CodeDeploy Deployment ID: ${DEPLOYMENT_ID}"

      - name: Get ALB endpoint
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names delightful-deploy-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "dns=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "url=http://${ALB_DNS}" >> $GITHUB_OUTPUT

  smoke-test:
    name: Smoke Tests
    needs: deploy-ecs
    if: always() && needs.deploy-ecs.result == 'success'  # deploy-ecs ì„±ê³µ ì‹œì—ë§Œ
    runs-on: ubuntu-latest

    steps:
      - name: Wait for service warmup
        run: sleep 30

      - name: Health check
        run: |
          ALB_DNS="${{ needs.deploy-ecs.outputs.alb-dns }}"
          MAX_RETRIES=10
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            for PATH in "/api/health" "/health" "/"; do
              if curl -fsS "http://${ALB_DNS}${PATH}" --max-time 10 >/dev/null; then
                echo "âœ“ Health check passed at ${PATH}!"
                exit 0
              fi
            done
            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 10
          done
          echo "âœ— Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: API endpoint test
        run: |
          ALB_DNS="${{ needs.deploy-ecs.outputs.alb-dns }}"

          echo "Testing root endpoint..."
          curl -fsS "http://${ALB_DNS}/" --max-time 10 >/dev/null || echo "root endpoint not available"

          echo "Testing /api/health..."
          curl -fsS "http://${ALB_DNS}/api/health" --max-time 10 >/dev/null || echo "/api/health not available"

  store-artifacts:
    name: Store Deployment Artifacts
    needs: [create-release, build-and-test, deploy-ecs]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create deployment manifest
        run: |
          RELEASE_TAG="${{ needs.create-release.outputs.release-tag || 'unknown' }}"
          IMAGE_TAG="${{ needs.build-and-test.outputs.image-tag }}"
          REPO_URL="${{ github.event.inputs.target_repository || 'unknown' }}"

          cat > deployment-manifest.json <<EOF
          {
            "deployment_id": "${{ github.run_id }}",
            "release_tag": "${RELEASE_TAG}",
            "release_url": "${{ needs.create-release.outputs.release-url || 'N/A' }}",
            "image_tag": "${IMAGE_TAG}",
            "target_repository": "${REPO_URL}",
            "commit_sha": "${{ github.sha }}",
            "environment": "${{ github.event.inputs.environment || 'dev' }}",
            "app_port": "${{ needs.build-and-test.outputs.app-port }}",
            "cpu": "${{ needs.build-and-test.outputs.cpu }}",
            "memory": "${{ needs.build-and-test.outputs.memory }}",
            "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployed_by": "${{ github.actor }}"
          }
          EOF

          echo "Deployment Manifest:"
          cat deployment-manifest.json

      - name: Upload deployment manifest to S3
        run: |
          RELEASE_TAG="${{ needs.create-release.outputs.release-tag || github.run_id }}"
          S3_BUCKET="delightful-deploy-artifacts-513348493870"
          S3_KEY="deployments/${RELEASE_TAG}/manifest.json"

          aws s3 cp deployment-manifest.json "s3://${S3_BUCKET}/${S3_KEY}"
          echo "Uploaded manifest to s3://${S3_BUCKET}/${S3_KEY}"

      - name: Upload AppSpec to S3
        run: |
          RELEASE_TAG="${{ needs.create-release.outputs.release-tag || github.run_id }}"
          S3_BUCKET="delightful-deploy-artifacts-513348493870"

          # Download Dockerfile from S3 (generated by AI analyzer)
          aws s3 cp "s3://${S3_BUCKET}/generated/${{ github.sha }}/Dockerfile" ./Dockerfile || echo "Dockerfile not found"

          # Upload to release artifacts
          if [ -f ./Dockerfile ]; then
            aws s3 cp ./Dockerfile "s3://${S3_BUCKET}/deployments/${RELEASE_TAG}/Dockerfile"
            echo "Uploaded Dockerfile to s3://${S3_BUCKET}/deployments/${RELEASE_TAG}/Dockerfile"
          fi

  notify:
    name: Notify Results
    needs: [create-release, build-and-test, deploy-ecs, smoke-test, store-artifacts]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.smoke-test.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=ðŸŽ‰" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          PAYLOAD=$(jq -n \
            --arg text "${{ steps.status.outputs.emoji }} Deployment ${{ steps.status.outputs.status }}" \
            --arg repo "${{ github.repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg actor "${{ github.actor }}" \
            --arg status "${{ steps.status.outputs.status }}" \
            --arg color "${{ steps.status.outputs.color }}" \
            --arg url "${{ needs.deploy-ecs.outputs.url }}" \
            '{
              text: $text,
              attachments: [{
                color: $color,
                fields: [
                  {title: "Repository", value: $repo, short: true},
                  {title: "Commit", value: $sha, short: true},
                  {title: "Triggered by", value: $actor, short: true},
                  {title: "Status", value: $status, short: true},
                  {title: "URL", value: $url, short: false}
                ]
              }]
            }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            $SLACK_WEBHOOK_URL || echo "Slack notification failed"

      - name: Update DynamoDB deployment status
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          DEPLOYMENT_ID="deploy-${SHORT_SHA}"
          STATUS="${{ steps.status.outputs.status }}"

          aws dynamodb update-item \
            --table-name delightful-deploy-deployment-history \
            --key "{\"id\": {\"S\": \"${DEPLOYMENT_ID}\"}}" \
            --update-expression "SET #status = :status, completed_at = :timestamp" \
            --expression-attribute-names '{"#status": "status"}' \
            --expression-attribute-values "{
              \":status\": {\"S\": \"${STATUS}\"},
              \":timestamp\": {\"S\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}
            }"

      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ needs.build-and-test.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**ALB URL:** ${{ needs.deploy-ecs.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
