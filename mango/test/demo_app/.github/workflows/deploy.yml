name: CI/CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production

env:
  AWS_REGION: ap-northeast-2
  ECR_REGISTRY: 513348493870.dkr.ecr.ap-northeast-2.amazonaws.com
  ECR_REPOSITORY: delightful-deploy
  ECS_CLUSTER: delightful-deploy-cluster
  ECS_SERVICE: delightful-deploy-service

jobs:
  build-and-test:
    name: Build & Test
    runs-on: ubuntu-latest

    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="deploy-${SHORT_SHA}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build Docker image
        run: |
          docker build -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.image-tag }} \
                       -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest \
                       ./test/demo_app

      - name: Run security scan
        run: |
          echo "Running security scan..."
          # Add Trivy or other security scanning here

      - name: Push to ECR
        run: |
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.image-tag }}
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest

      - name: Update DynamoDB deployment record
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          DEPLOYMENT_ID="deploy-${{ steps.meta.outputs.short-sha }}"

          aws dynamodb put-item \
            --table-name delightful-deploy-deployment-history \
            --item "{
              \"id\": {\"S\": \"${DEPLOYMENT_ID}\"},
              \"timestamp\": {\"S\": \"${TIMESTAMP}\"},
              \"repository\": {\"S\": \"${{ github.repository }}\"},
              \"commit_sha\": {\"S\": \"${{ github.sha }}\"},
              \"branch\": {\"S\": \"${{ github.ref_name }}\"},
              \"pusher\": {\"S\": \"${{ github.actor }}\"},
              \"image_tag\": {\"S\": \"${{ steps.meta.outputs.image-tag }}\"},
              \"status\": {\"S\": \"building\"}
            }"

  deploy-infrastructure:
    name: Deploy Infrastructure (Terraform)
    needs: build-and-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: ./mango/infrastructure/terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: ./mango/infrastructure/terraform
        run: |
          terraform plan \
            -var="image_tag=${{ needs.build-and-test.outputs.image-tag }}" \
            -var="commit_sha=${{ github.sha }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ./mango/infrastructure/terraform
        run: terraform apply -auto-approve tfplan

      - name: Get ECS Service info
        id: ecs
        run: |
          ECS_INFO=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0]')

          RUNNING_COUNT=$(echo $ECS_INFO | jq -r '.runningCount')
          DESIRED_COUNT=$(echo $ECS_INFO | jq -r '.desiredCount')

          echo "running-count=${RUNNING_COUNT}" >> $GITHUB_OUTPUT
          echo "desired-count=${DESIRED_COUNT}" >> $GITHUB_OUTPUT

  deploy-ecs:
    name: Deploy to ECS
    needs: [build-and-test, deploy-infrastructure]
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Force new ECS deployment
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment

      - name: Wait for deployment
        run: |
          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Get ALB endpoint
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names delightful-deploy-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          echo "dns=${ALB_DNS}" >> $GITHUB_OUTPUT
          echo "url=http://${ALB_DNS}" >> $GITHUB_OUTPUT

  smoke-test:
    name: Smoke Tests
    needs: deploy-ecs
    runs-on: ubuntu-latest

    steps:
      - name: Wait for service warmup
        run: sleep 30

      - name: Health check
        run: |
          ALB_DNS="${{ needs.deploy-ecs.outputs.alb-dns }}"
          MAX_RETRIES=10
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."

            if curl -f "http://${ALB_DNS}/health" --max-time 10; then
              echo "âœ“ Health check passed!"
              exit 0
            fi

            RETRY_COUNT=$((RETRY_COUNT + 1))
            sleep 10
          done

          echo "âœ— Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: API endpoint test
        run: |
          ALB_DNS="${{ needs.deploy-ecs.outputs.alb-dns }}"

          echo "Testing root endpoint..."
          curl -f "http://${ALB_DNS}/" || exit 1

          echo "Testing API status endpoint..."
          curl -f "http://${ALB_DNS}/api/status" || exit 1

  notify:
    name: Notify Results
    needs: [build-and-test, deploy-ecs, smoke-test]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.smoke-test.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=ðŸŽ‰" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          PAYLOAD=$(jq -n \
            --arg text "${{ steps.status.outputs.emoji }} Deployment ${{ steps.status.outputs.status }}" \
            --arg repo "${{ github.repository }}" \
            --arg sha "${{ github.sha }}" \
            --arg actor "${{ github.actor }}" \
            --arg status "${{ steps.status.outputs.status }}" \
            --arg color "${{ steps.status.outputs.color }}" \
            --arg url "${{ needs.deploy-ecs.outputs.url }}" \
            '{
              text: $text,
              attachments: [{
                color: $color,
                fields: [
                  {title: "Repository", value: $repo, short: true},
                  {title: "Commit", value: $sha, short: true},
                  {title: "Triggered by", value: $actor, short: true},
                  {title: "Status", value: $status, short: true},
                  {title: "URL", value: $url, short: false}
                ]
              }]
            }')

          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            $SLACK_WEBHOOK_URL || echo "Slack notification failed"

      - name: Update DynamoDB deployment status
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          DEPLOYMENT_ID="deploy-${SHORT_SHA}"
          STATUS="${{ steps.status.outputs.status }}"

          aws dynamodb update-item \
            --table-name delightful-deploy-deployment-history \
            --key "{\"id\": {\"S\": \"${DEPLOYMENT_ID}\"}}" \
            --update-expression "SET #status = :status, completed_at = :timestamp" \
            --expression-attribute-names '{"#status": "status"}' \
            --expression-attribute-values "{
              \":status\": {\"S\": \"${STATUS}\"},
              \":timestamp\": {\"S\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}
            }"

      - name: Create deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${{ needs.build-and-test.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**ALB URL:** ${{ needs.deploy-ecs.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
